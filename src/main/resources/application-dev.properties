# 配置数据库连接
spring.datasource.url=jdbc:mysql://localhost:3306/springdatajpa?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 配置jpa
# debug用，上线关闭
spring.jpa.show-sql=false
# 程序运行时创建表，如果有表，不会创建表
spring.jpa.hibernate.ddl-auto=update
# 命名规则默认按照interfaceName->interface_name,https://blog.csdn.net/alalala2015/article/details/102408360
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
# 用新的数据库，需要设置新的方言
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
# 此属性控制从池返回的连接的默认自动提交行为
spring.datasource.hikari.auto-commit=true
# 配置kafka集群
spring.kafka.bootstrap-servers=hadoop101:9092,hadoop102:9092
# 配置生产者
# 重试次数
spring.kafka.producer.retries=0
# 批量大小
spring.kafka.producer.batch-size=16384
# 生产者缓冲区大小
spring.kafka.producer.buffer-memory=33554432
# 生产者指定kafka序列化类
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
# 提交延时
spring.kafka.producer.properties.linger.ms=50
# 配置消费者
# 是否自动提交offset
spring.kafka.consumer.enable-auto-commit=false
# 提交offset延时，接收到消息后多久提交offset
spring.kafka.consumer.auto-commit-interval=50ms
# 消费者指定kafka的发序列化类
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer
# 配置kafka消费组
spring.kafka.consumer.group-id=meethigher
# 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)
spring.kafka.consumer.properties.session.timeout.ms=15000